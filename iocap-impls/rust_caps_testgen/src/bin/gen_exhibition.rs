use std::{error::Error, fs::File, io::Write};

use clap::Parser;

use rand::{thread_rng, Rng};
use rust_caps::capability::v2024::rand::CapTestCase;

// TODO update to be similar to gen_rand_csv

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    secret_key_hex: String,
    capability_hex: String,

    /// Number of capabilities to generate for each category.
    #[arg(long, default_value_t=128)]
    n_secrets: u32,

    /// Number of capabilities to generate for each category.
    #[arg(long, default_value_t=2048)]
    n_caps: usize,

    /// Generate capabilities with no caveats enabled
    #[arg(long, default_value_t=true)]
    gen_nocav: std::primitive::bool,

    /// Generate capabilities with exactly one caveat enabled
    #[arg(long, default_value_t=true)]
    gen_1cav: std::primitive::bool,

    /// Generate capabilities with two caveats enabled
    #[arg(long, default_value_t=true)]
    gen_2cav: std::primitive::bool,

    /// When unset, will generate both valid and invalid caveats.
    /// When set to true, will generate valid caveats only.
    /// When set to false, will generate invalid caveats only.
    #[arg(long)]
    valid_cavs: Option<bool>,

    /// When false, will only generate valid signatures
    /// When true, will generate random alternate signatures for no-caveat and reuse previous signatures for caveated cases.
    #[arg(long, default_value_t=false)]
    invalid_sig: std::primitive::bool
}

#[derive(Debug, Clone, Copy)]
enum KindOfRandomCap {
    Valid0Cav,
    Valid1Cav,
    Valid2Cav
}

fn write_out_secret_keys(secrets: &[u128], path: &str) -> Result<(), std::io::Error> {
    let mut file = File::create(path)?;
    
    write!(file, "// Autogenerated secret key file by gen_exhibition\n")?;
    for secret in secrets {
        write!(file, "{:032x}\n", secret)?;
    }

    Ok(())
}
fn write_out_caps(caps: &[CapTestCase], path: &str) -> Result<(), std::io::Error> {
    let mut file = File::create(path)?;
    
    write!(file, "// Autogenerated capability file by gen_exhibition\n")?;
    for cap in caps {
        // Bluespec struct has data first, sig last. Bluespec rules state that means sig starts at byte 0.
        // Verilog hex-file rules interpret words as big-endian (??) so that means we want to put byte 0 of cap.sig at the *end*.
        // That means write out cap.sig as big-endian (the default) *after* writing out cap.data
        write!(file, "{:032x}{:032x} \n", cap.data, cap.sig)?;
    }

    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();

    if args.invalid_sig {
        todo!("Implement invalid sig behaviour")
    }

    if args.n_secrets >= (1 << 23) {
        panic!("args.n_secrets cannot be greater than 23 bits");
    }

    let mut rng = thread_rng();

    // generate secret keys
    let secret_keys: Vec<u128> = (0..args.n_secrets).into_iter().map(|_| {
        rng.gen()
    }).collect();

    // write out the secret key file
    write_out_secret_keys(&secret_keys, &args.secret_key_hex)?;

    // generate capabilities
    let choices = {
        let mut choices = vec![];

        if args.gen_nocav {
            choices.push(KindOfRandomCap::Valid0Cav);
        }
        if args.gen_1cav {
            choices.push(KindOfRandomCap::Valid1Cav);
        }
        if args.gen_2cav {
            choices.push(KindOfRandomCap::Valid2Cav);
        }

        choices
    };

    let mut caps: Vec<CapUnderTest> = vec![];
    
    while caps.len() < args.n_caps {
        let secret_key_id: u32 = rng.gen_range(0..args.n_secrets);
        let secret_key = secret_keys[secret_key_id as usize];

        let kind = choices[rng.gen_range(0..choices.len())];
        let base_align = 10;
        let length = ChooseRand::Between(0, 1 << 64);

        let gen_result = match kind {
            KindOfRandomCap::Valid0Cav => random_nocav_cap(
                ChooseRand::Specific(secret_key),
                ChooseRand::Specific(secret_key_id),
                base_align,
                length,
                None,
            ),
            KindOfRandomCap::Valid1Cav => random_valid_1cav_cap(
                ChooseRand::Specific(secret_key),
                ChooseRand::Specific(secret_key_id),
                base_align,
                length,
                None
            ),
            KindOfRandomCap::Valid2Cav => random_valid_2cav_cap(
                ChooseRand::Specific(secret_key),
                ChooseRand::Specific(secret_key_id),
                base_align,
                length,
                None
            ),
        };

        match gen_result {
            Ok((_secret, _secret_key_id, cap)) => caps.push(cap),
            Err(_) => continue
        }
    }

    // Write out the capability file
    write_out_caps(&caps, &args.capability_hex)?;
    

    Ok(())
}